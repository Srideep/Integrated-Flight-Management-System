function add_and_connect_nav_logic(modelName)
% ADD_AND_CONNECT_NAV_LOGIC Creates the complete navigation logic in Simulink
%
% This function builds the actual Simulink model by adding blocks and 
% connecting them according to the navigation data flow. Think of this as
% the "assembly line" that puts together all the navigation components.

    % =====================================================================
    % STEP 1: CREATE INPUT BLOCKS
    % =====================================================================
    % These blocks represent the inputs to our navigation system.
    % In a real aircraft, these would come from sensors and flight computers.
    
    fprintf('  Creating input blocks...\n');
    
    % Current aircraft position input
    % This simulates the GPS or inertial navigation system providing current position
    add_block('simulink/Sources/In1', [modelName '/Current_Position']);
    set_param([modelName '/Current_Position'], ...
        'OutDataTypeStr', 'Bus: PositionBus', ...
        'Position', [50, 100, 120, 140]);
    
    % Active flight plan input
    % This represents the planned route loaded into the flight management system
    add_block('simulink/Sources/In1', [modelName '/Flight_Plan']);
    set_param([modelName '/Flight_Plan'], ...
        'OutDataTypeStr', 'Bus: FlightPlanBus', ...
        'Position', [50, 200, 120, 240]);
    
    % Active leg index - which segment of the flight plan we're currently flying
    % This tells us which two waypoints define our current navigation leg
    add_block('simulink/Sources/In1', [modelName '/Active_Leg_Index']);
    set_param([modelName '/Active_Leg_Index'], ...
        'OutDataTypeStr', 'uint8', ...
        'Position', [50, 300, 120, 340]);

    % =====================================================================
    % STEP 2: CREATE WAYPOINT EXTRACTION LOGIC
    % =====================================================================
    % Before we can do navigation calculations, we need to extract the 
    % current and next waypoints from the flight plan array.
    
    fprintf('  Creating waypoint extraction logic...\n');
    
    % This MATLAB Function block extracts the current leg waypoints
    add_block('simulink/User-Defined Functions/MATLAB Function', ...
        [modelName '/Extract_Current_Leg']);
    set_param([modelName '/Extract_Current_Leg'], ...
        'Position', [200, 250, 320, 350]);
    
    % Configure the MATLAB Function block with our waypoint extraction logic
    % This is where we tell Simulink what code to execute inside this block
    waypoint_extraction_code = sprintf(['function [start_lat, start_lon, end_lat, end_lon] = fcn(flight_plan, leg_index)\n'...
        '%% Extract waypoints for the current navigation leg\n'...
        '% This function pulls out the latitude and longitude coordinates\n'...
        '% for the two waypoints that define our current flight path segment\n\n'...
        'coder.extrinsic(''fprintf'');\n\n'...
        '% Safety check: ensure leg index is valid\n'...
        'if leg_index < 1 || leg_index >= flight_plan.numWaypoints\n'...
        '    % If invalid, use first leg as fallback\n'...
        '    fprintf(''Warning: Invalid leg index, using first leg\\n'');\n'...
        '    leg_index = uint8(1);\n'...
        'end\n\n'...
        '% Extract the start waypoint (current leg)\n'...
        'start_lat = flight_plan.waypoints(leg_index).latitude;\n'...
        'start_lon = flight_plan.waypoints(leg_index).longitude;\n\n'...
        '% Extract the end waypoint (next waypoint)\n'...
        'end_lat = flight_plan.waypoints(leg_index + 1).latitude;\n'...
        'end_lon = flight_plan.waypoints(leg_index + 1).longitude;\n']);
    
    % Apply this code to the MATLAB Function block
    set_param([modelName '/Extract_Current_Leg'], 'Script', waypoint_extraction_code);

    % =====================================================================
    % STEP 3: CREATE CORE NAVIGATION CALCULATION BLOCKS
    % =====================================================================
    % These blocks implement the mathematical algorithms we discussed earlier.
    % Each block encapsulates one of the key navigation functions.
    
    fprintf('  Creating navigation calculation blocks...\n');
    
    % Cross-Track Error Calculation Block
    % This determines how far off course the aircraft is
    add_block('simulink/User-Defined Functions/MATLAB Function', ...
        [modelName '/Calculate_Cross_Track_Error']);
    set_param([modelName '/Calculate_Cross_Track_Error'], ...
        'Position', [400, 100, 580, 180]);
    
    % Configure the cross-track error calculation
    xte_code = sprintf(['function xte_nm = fcn(lat_deg, lon_deg, start_lat_deg, start_lon_deg, end_lat_deg, end_lon_deg)\n'...
        '%% Cross-track error calculation using great circle mathematics\n'...
        '% This implements the spherical trigonometry we discussed earlier\n\n'...
        '% Convert all coordinates from degrees to radians\n'...
        '% Trigonometric functions work with radians, not degrees\n'...
        'lat = lat_deg * pi / 180;\n'...
        'lon = lon_deg * pi / 180;\n'...
        'start_lat = start_lat_deg * pi / 180;\n'...
        'start_lon = start_lon_deg * pi / 180;\n'...
        'end_lat = end_lat_deg * pi / 180;\n'...
        'end_lon = end_lon_deg * pi / 180;\n\n'...
        '% Earth radius in nautical miles\n'...
        'R = 3440.065;\n\n'...
        '% Calculate distance from start point to aircraft position\n'...
        '% This uses the haversine formula for accuracy on a sphere\n'...
        'd13 = 2 * asin(sqrt(sin((lat - start_lat)/2)^2 + ...\n'...
        '                cos(start_lat)*cos(lat)*sin((lon - start_lon)/2)^2));\n\n'...
        '% Calculate bearing from start to aircraft\n'...
        'bearing13 = atan2(sin(lon - start_lon)*cos(lat), ...\n'...
        '                  cos(start_lat)*sin(lat) - sin(start_lat)*cos(lat)*cos(lon - start_lon));\n\n'...
        '% Calculate bearing from start to end waypoint (desired track)\n'...
        'bearing12 = atan2(sin(end_lon - start_lon)*cos(end_lat), ...\n'...
        '                  cos(start_lat)*sin(end_lat) - sin(start_lat)*cos(end_lat)*cos(end_lon - start_lon));\n\n'...
        '% Cross-track error calculation\n'...
        '% The key insight: sin(bearing_diff) gives perpendicular offset\n'...
        'xte_rad = asin(sin(d13) * sin(bearing13 - bearing12));\n'...
        'xte_nm = R * xte_rad;\n']);
    
    set_param([modelName '/Calculate_Cross_Track_Error'], 'Script', xte_code);
    
    % Distance and Bearing Calculation Block
    % This tells us how far and in what direction to the next waypoint
    add_block('simulink/User-Defined Functions/MATLAB Function', ...
        [modelName '/Calculate_Distance_Bearing']);
    set_param([modelName '/Calculate_Distance_Bearing'], ...
        'Position', [400, 200, 580, 280]);
    
    % Configure the distance and bearing calculation
    dist_bearing_code = sprintf(['function [distance_nm, bearing_deg] = fcn(lat1_deg, lon1_deg, lat2_deg, lon2_deg)\n'...
        '%% Great circle distance and bearing calculation\n'...
        '% This implements the haversine formula for spherical Earth\n\n'...
        '% Convert degrees to radians for trigonometric calculations\n'...
        'lat1 = lat1_deg * pi / 180;\n'...
        'lon1 = lon1_deg * pi / 180;\n'...
        'lat2 = lat2_deg * pi / 180;\n'...
        'lon2 = lon2_deg * pi / 180;\n\n'...
        '% Haversine formula for great circle distance\n'...
        'dlat = lat2 - lat1;\n'...
        'dlon = lon2 - lon1;\n'...
        'a = sin(dlat/2)^2 + cos(lat1)*cos(lat2)*sin(dlon/2)^2;\n'...
        'c = 2 * atan2(sqrt(a), sqrt(1-a));\n\n'...
        '% Earth radius in nautical miles\n'...
        'R = 3440.065;\n'...
        'distance_nm = R * c;\n\n'...
        '% Initial bearing calculation\n'...
        '% This gives the compass direction to start traveling\n'...
        'y = sin(dlon) * cos(lat2);\n'...
        'x = cos(lat1)*sin(lat2) - sin(lat1)*cos(lat2)*cos(dlon);\n'...
        'bearing_rad = atan2(y, x);\n\n'...
        '% Convert to degrees and normalize to 0-360 range\n'...
        'bearing_deg = mod(bearing_rad * 180 / pi + 360, 360);\n']);
    
    set_param([modelName '/Calculate_Distance_Bearing'], 'Script', dist_bearing_code);
    
    % Bank Angle Command Calculation Block
    % This converts navigation information into flight control commands
    add_block('simulink/User-Defined Functions/MATLAB Function', ...
        [modelName '/Calculate_Bank_Angle_Cmd']);
    set_param([modelName '/Calculate_Bank_Angle_Cmd'], ...
        'Position', [400, 300, 580, 380]);
    
    % Configure the bank angle command calculation
    bank_cmd_code = sprintf(['function bank_angle_deg = fcn(xte_nm, bearing_deg)\n'...
        '%% Bank angle command generation using proportional control\n'...
        '% This is where navigation math becomes flight control\n\n'...
        '% Control gains - these determine how aggressively we correct\n'...
        'K = 5;           %% Gain in degrees per nautical mile\n'...
        'MAX_BANK = 25;   %% Saturation limit for passenger comfort and safety\n\n'...
        '% Proportional controller: bank angle proportional to cross-track error\n'...
        '% Negative sign ensures correct response (bank left for right-of-course error)\n'...
        'bank_angle_deg = -K * xte_nm;\n\n'...
        '% Apply saturation limits to prevent excessive bank angles\n'...
        'if bank_angle_deg > MAX_BANK\n'...
        '    bank_angle_deg = MAX_BANK;\n'...
        'elseif bank_angle_deg < -MAX_BANK\n'...
        '    bank_angle_deg = -MAX_BANK;\n'...
        'end\n']);
    
    set_param([modelName '/Calculate_Bank_Angle_Cmd'], 'Script', bank_cmd_code);

    % =====================================================================
    % STEP 4: CREATE OUTPUT ASSEMBLY BLOCK
    % =====================================================================
    % This block packages all our calculated values into the output bus structure
    
    fprintf('  Creating output assembly logic...\n');
    
    add_block('simulink/User-Defined Functions/MATLAB Function', ...
        [modelName '/Assemble_Navigation_Output']);
    set_param([modelName '/Assemble_Navigation_Output'], ...
        'Position', [650, 200, 780, 300]);
    
    % Configure the output assembly logic
    output_assembly_code = sprintf(['function nav_output = fcn(xte_nm, distance_nm, bearing_deg, bank_cmd_deg)\n'...
        '%% Assemble all navigation calculations into output bus\n'...
        '% This creates the structured output that other systems will use\n\n'...
        '% Initialize the output bus structure\n'...
        'nav_output = struct();\n\n'...
        '% Pack all calculated values into the navigation bus\n'...
        'nav_output.CrossTrackError = xte_nm;\n'...
        'nav_output.DistanceToGo = distance_nm;\n'...
        'nav_output.DesiredCourse = bearing_deg;\n'...
        'nav_output.BankAngleCmd = bank_cmd_deg;\n']);
    
    set_param([modelName '/Assemble_Navigation_Output'], 'Script', output_assembly_code);

    % =====================================================================
    % STEP 5: CREATE OUTPUT PORT
    % =====================================================================
    % This is where other systems can access our navigation calculations
    
    add_block('simulink/Sinks/Out1', [modelName '/Navigation_Output']);
    set_param([modelName '/Navigation_Output'], ...
        'Position', [820, 230, 870, 270]);

    % =====================================================================
    % STEP 6: CREATE ALL THE SIGNAL CONNECTIONS
    % =====================================================================
    % Now we wire everything together to create the complete data flow.
    % Think of this as connecting the plumbing in our navigation system.
    
    fprintf('  Connecting all blocks with signal lines...\n');
    
    % Connect current position to cross-track error calculation
    % The aircraft position feeds into multiple calculations
    add_line(modelName, 'Current_Position/1', 'Calculate_Cross_Track_Error/1');
    add_line(modelName, 'Current_Position/1', 'Calculate_Distance_Bearing/1');
    
    % Connect flight plan and leg index to waypoint extraction
    add_line(modelName, 'Flight_Plan/1', 'Extract_Current_Leg/1');
    add_line(modelName, 'Active_Leg_Index/1', 'Extract_Current_Leg/2');
    
    % Connect waypoint extraction outputs to navigation calculations
    % These connections create the dependency chain: waypoints → calculations → commands
    add_line(modelName, 'Extract_Current_Leg/1', 'Calculate_Cross_Track_Error/3');  % start_lat
    add_line(modelName, 'Extract_Current_Leg/2', 'Calculate_Cross_Track_Error/4');  % start_lon
    add_line(modelName, 'Extract_Current_Leg/3', 'Calculate_Cross_Track_Error/5');  % end_lat
    add_line(modelName, 'Extract_Current_Leg/4', 'Calculate_Cross_Track_Error/6');  % end_lon
    
    % Connect to distance/bearing calculation (to next waypoint)
    add_line(modelName, 'Extract_Current_Leg/3', 'Calculate_Distance_Bearing/3');   % end_lat
    add_line(modelName, 'Extract_Current_Leg/4', 'Calculate_Distance_Bearing/4');   % end_lon
    
    % Connect navigation calculations to bank angle command
    add_line(modelName, 'Calculate_Cross_Track_Error/1', 'Calculate_Bank_Angle_Cmd/1');
    add_line(modelName, 'Calculate_Distance_Bearing/2', 'Calculate_Bank_Angle_Cmd/2');
    
    % Connect all outputs to the final assembly block
    add_line(modelName, 'Calculate_Cross_Track_Error/1', 'Assemble_Navigation_Output/1');
    add_line(modelName, 'Calculate_Distance_Bearing/1', 'Assemble_Navigation_Output/2');
    add_line(modelName, 'Calculate_Distance_Bearing/2', 'Assemble_Navigation_Output/3');
    add_line(modelName, 'Calculate_Bank_Angle_Cmd/1', 'Assemble_Navigation_Output/4');
    
    % Connect final output
    add_line(modelName, 'Assemble_Navigation_Output/1', 'Navigation_Output/1');

    % =====================================================================
    % STEP 7: ADD SIGNAL LABELS FOR CLARITY
    % =====================================================================
    % These labels make the model easier to understand and debug
    
    fprintf('  Adding signal labels for documentation...\n');
    
    % Add descriptive labels to key signal lines
    % This makes the model self-documenting
    set_param([modelName '/Current_Position'], 'Name', 'Aircraft Position\n(GPS/INS)');
    set_param([modelName '/Flight_Plan'], 'Name', 'Active Flight Plan\n(Route waypoints)');
    set_param([modelName '/Active_Leg_Index'], 'Name', 'Current Leg\n(Which segment)');
    set_param([modelName '/Navigation_Output'], 'Name', 'Navigation Commands\n(To autopilot)');

    % =====================================================================
    % STEP 8: CONFIGURE BLOCK VISUAL PROPERTIES
    % =====================================================================
    % Make the model look professional and easy to understand
    
    fprintf('  Configuring visual properties...\n');
    
    % Set colors for different types of blocks to improve visual organization
    % Input blocks in light blue
    set_param([modelName '/Current_Position'], 'BackgroundColor', 'lightBlue');
    set_param([modelName '/Flight_Plan'], 'BackgroundColor', 'lightBlue');
    set_param([modelName '/Active_Leg_Index'], 'BackgroundColor', 'lightBlue');
    
    % Processing blocks in light green
    set_param([modelName '/Extract_Current_Leg'], 'BackgroundColor', 'lightGreen');
    set_param([modelName '/Calculate_Cross_Track_Error'], 'BackgroundColor', 'lightGreen');
    set_param([modelName '/Calculate_Distance_Bearing'], 'BackgroundColor', 'lightGreen');
    set_param([modelName '/Calculate_Bank_Angle_Cmd'], 'BackgroundColor', 'lightGreen');
    set_param([modelName '/Assemble_Navigation_Output'], 'BackgroundColor', 'lightGreen');
    
    % Output block in light coral
    set_param([modelName '/Navigation_Output'], 'BackgroundColor', 'lightCoral');

    fprintf('  Navigation logic assembly complete!\n');
end
